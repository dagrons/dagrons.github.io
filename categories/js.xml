<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NuLL (关于文章 js)</title><link>https://dagrons.github.io/</link><description></description><atom:link href="https://dagrons.github.io/categories/js.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><copyright>Contents © 2021 &lt;a href="mailto:heyuehuii@126.com"&gt;dagrons&lt;/a&gt; </copyright><lastBuildDate>Fri, 20 Aug 2021 15:13:52 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Components, State machine, state, events, action</title><link>https://dagrons.github.io/posts/components-state-machine-state-events-action/</link><dc:creator>dagrons</dc:creator><description>&lt;div&gt;&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;The world is a state machine driven by events&lt;/p&gt;
&lt;p&gt;events are what components listening on&lt;/p&gt;
&lt;p&gt;components responds to different events with different actions&lt;/p&gt;
&lt;p&gt;different components cares only about events they listen on&lt;/p&gt;
&lt;p&gt;state are what the actions condition on&lt;/p&gt;
&lt;p&gt;Event handlers are actions registered on a event&lt;/p&gt;
&lt;p&gt;some components share on some state while some do not&lt;/p&gt;
&lt;p&gt;the actions of one components may affect the states of other components&lt;/p&gt;
&lt;p&gt;the actions of one component can emit events to others.&lt;/p&gt;
&lt;p&gt;It's always a bad practice for one component to emit events to itself.&lt;/p&gt;
&lt;p&gt;in real world, all components runs on different thread, however it's not true in programming&lt;/p&gt;
&lt;h2&gt;Event&lt;/h2&gt;
&lt;p&gt;Understanding the capture phrase and bubble phrase of event passing, we can choose to register our event listener on the capture phrase or bubble phrase with the third optional parameter which is default to false(bubble)&lt;/p&gt;
&lt;p&gt;We can use e.target to refer to the event target component and use e.srcElement to refer to the source component, however there may be no srcElement for some events such as ajax events.&lt;/p&gt;
&lt;p&gt;event can be created with &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nx"&gt;event&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ow"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;typeArg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;eventInit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;some important APIs for events are stopPropagation and preventDefault &lt;/p&gt;
&lt;h2&gt;ICC (Inter Component Communication)&lt;/h2&gt;
&lt;p&gt;Shared state: If A and B share some same state, it's ok to operate on the state directly&lt;/p&gt;
&lt;p&gt;Function as args: A can pass a encapsulated function for B to call, executed immediately&lt;/p&gt;
&lt;p&gt;Emit a event: A can emit a event to B to trigger B's event listener, not executed immediately&lt;/p&gt;
&lt;p&gt;Children -&amp;gt; parent: parent pass function to children as props/args, be careful to bind "this"!&lt;/p&gt;
&lt;p&gt;Parent -&amp;gt; children: props/args&lt;/p&gt;
&lt;p&gt;Child &amp;lt;-&amp;gt; Child: shared context/state&lt;/p&gt;
&lt;p&gt;The third approach is not recommended&lt;/p&gt;
&lt;h2&gt;React&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;useState, useEffect, useReducer, when and why?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;in react, "state" are special state do something with ui behaviors, and can only be changed with setState, which will not be executed immediately, but will be changed in order they been pushed into the queue(which is synchronous opeation)
in other words, react "state" is what render action conditions on.&lt;/p&gt;
&lt;p&gt;react "state" are not recommended when the next value depends on the previous value.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;suppose&lt;/span&gt; &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;component&lt;/span&gt; &lt;span class="nv"&gt;has&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;state&lt;/span&gt; &lt;span class="nv"&gt;binary&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;only&lt;/span&gt; &lt;span class="nv"&gt;actions&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;component&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;state&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;invert&lt;/span&gt; &lt;span class="nv"&gt;it&lt;/span&gt;, 
&lt;span class="nv"&gt;A&lt;/span&gt; : 
&lt;span class="nv"&gt;Invert&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;binary&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;: &lt;span class="nv"&gt;setBinary&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nv"&gt;setBinary&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;As&lt;/span&gt; &lt;span class="nv"&gt;we&lt;/span&gt; &lt;span class="nv"&gt;already&lt;/span&gt; &lt;span class="nv"&gt;know&lt;/span&gt;, &lt;span class="nv"&gt;setBinary&lt;/span&gt; &lt;span class="nv"&gt;are&lt;/span&gt; &lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;executed&lt;/span&gt; &lt;span class="nv"&gt;immediately&lt;/span&gt;, &lt;span class="nv"&gt;instead&lt;/span&gt;, &lt;span class="nv"&gt;they&lt;/span&gt; &lt;span class="nv"&gt;are&lt;/span&gt; &lt;span class="nv"&gt;pushed&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;queue&lt;/span&gt; &lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;order&lt;/span&gt;
&lt;span class="k"&gt;If&lt;/span&gt; &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;invert&lt;/span&gt; &lt;span class="nv"&gt;Binary&lt;/span&gt; &lt;span class="nv"&gt;twice&lt;/span&gt; &lt;span class="nv"&gt;when&lt;/span&gt; &lt;span class="nv"&gt;binary&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="nv"&gt;what&lt;/span&gt; &lt;span class="nv"&gt;we&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt; &lt;span class="nv"&gt;finally&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;bianry&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;However&lt;/span&gt;, &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;second&lt;/span&gt; &lt;span class="nv"&gt;invert&lt;/span&gt; &lt;span class="nv"&gt;happens&lt;/span&gt; &lt;span class="nv"&gt;before&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;setState&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;first&lt;/span&gt; &lt;span class="nv"&gt;invert&lt;/span&gt; &lt;span class="nv"&gt;been&lt;/span&gt; &lt;span class="nv"&gt;executed&lt;/span&gt;. &lt;span class="k"&gt;Then&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;binary&lt;/span&gt; &lt;span class="nv"&gt;would&lt;/span&gt; &lt;span class="nv"&gt;be&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;, &lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;as&lt;/span&gt; &lt;span class="nv"&gt;we&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt;.
&lt;/pre&gt;
&lt;p&gt;To solve the above problem, we should useReducer.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;const binary = {value: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'invert':
      return {count: state.value^1};
    default:
      throw new Error();
  }
}

function Inverter() {
  const [state, dispatch] = useReducer(reducer, 1);
  return (
    &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&amp;gt;
      binary: {state.value}
      &lt;span class="nt"&gt;&amp;lt;button&lt;/span&gt; &lt;span class="na"&gt;onClick=&lt;/span&gt;&lt;span class="s"&gt;{()&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; dispatch({type: 'invert'})}&amp;gt;invert&lt;span class="nt"&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
    &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;/&amp;gt;
  );
}
&lt;/pre&gt;
&lt;p&gt;the dispatched actions are pushed into the queue and ensured to  be executed in FIFO order.&lt;/p&gt;
&lt;p&gt;Do not useReducer if useState works.&lt;/p&gt;
&lt;p&gt;in react, useEffect defined what to execute after first render when or react "state" changes.&lt;/p&gt;
&lt;p&gt;in react, components are organized in a tree structure, each components is a node on the tree.&lt;/p&gt;
&lt;p&gt;in react, each components have at least one action called render, which listen on render events.&lt;/p&gt;
&lt;p&gt;&lt;img alt="事件，状态，动作" src="https://dagrons.github.io/images/QQ%E6%88%AA%E5%9B%BE20210405222133.png"&gt;
&lt;img alt="共享状态-组件通信" src="https://dagrons.github.io/images/QQ%E6%88%AA%E5%9B%BE20210405213404.png"&gt;
&lt;img alt="React树形结构" src="https://dagrons.github.io/images/QQ%E6%88%AA%E5%9B%BE20210405222359.png"&gt;&lt;/p&gt;&lt;/div&gt;</description><category>js</category><guid>https://dagrons.github.io/posts/components-state-machine-state-events-action/</guid><pubDate>Mon, 05 Apr 2021 12:37:29 GMT</pubDate></item><item><title>js中的promise机制</title><link>https://dagrons.github.io/posts/jszhong-de-promiseji-zhi/</link><dc:creator>dagrons</dc:creator><description>&lt;div&gt;&lt;h2&gt;Js中的核心机制-Promise&lt;/h2&gt;
&lt;p&gt;“在异步中实现同步”&lt;/p&gt;
&lt;p&gt;如果说js中有什么东西造就了他的与众不同，我想，既不是functional programming这种几十年前的老东西，也不是None和undefined这种奇怪的机制，甚至于this的dynamic scope都不足以支撑js成为一门与众不同而独占前端市场的语言，而是他的异步机制，js是专为异步编程设计的语言，不只是体现在语法上，更重要的是其提供的基建。&lt;/p&gt;
&lt;p&gt;在前端开发中，相当大的一部分工作是在进行UI渲染和回调处理，这不仅是web独有的特点，而是针对几乎所有前端开发的共有特性，在前端逻辑中，我们经常关注于一个按钮被点击后会发生什么，当我们从服务器中获取数据后要干什么...，于是有了“事件流”的概念，我们将事件流想象成一个队列，主线程从事件流中不断取出事件，并进行处理。&lt;/p&gt;
&lt;p&gt;这里涉及两个问题，1. 主线程如何根据事件确定相应的处理逻辑？2. 主线程如何确保处理逻辑不会阻塞&lt;/p&gt;
&lt;p&gt;对于问题1，js中提供了相当多的机制，典型的例子就是DOM的事件监听机制，用户在各种事件上注册各种处理函数，从而确定事件对应的处理逻辑，还例如fetch的回调，用于执行fetch返回后的处理逻辑&lt;/p&gt;
&lt;p&gt;对于问题2，主线程如何确保处理逻辑不会阻塞，首先，我们要时刻谨记“js是单线程的”，也就是说，所有的操作都在一个线程内完成，这似乎很难理解，但回到我们之前的事件流模型，就不难发现，整个程序所做的事件不过是：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;event&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;pop_front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nx"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;虽然js是单线程的，但浏览器并非单线程，浏览器只是为每个window开一个js线程，一个UI渲染引擎。&lt;/p&gt;
&lt;p&gt;既然js是单线程的语言，所以要求我们的事件处理函数一定是不能阻塞我们的主线程，其中UI渲染事件会被交给UI渲染引擎进行处理，而fetch和setTimeout,setInterval，以及DOM的各种OnXXX事件，如何保证它们被处理的时候不阻塞呢，答案是：异步/non-blocking&lt;/p&gt;
&lt;p&gt;在js中，异步/non-blocking常与Promise挂钩&lt;/p&gt;
&lt;h3&gt;Promise&lt;/h3&gt;
&lt;p&gt;在js中，异步/non-blocking的含义就是将一个同步的过程分解成几个步骤，使得原来阻塞的处理逻辑变得不阻塞，举个例子：我们想要从server端获取数据，然后进行处理，但从server端获取数据的过程是会产生阻塞的，于是js提出了promise机制，首先它让fetch变成non-blocking的调用，然后允许我们对fetch的返回数据注册处理函数，但是这个处理函数是在fetch的返回数据确定后执行&lt;/p&gt;
&lt;p&gt;所以，什么是Promise机制呢：&lt;/p&gt;
&lt;h4&gt;Promise维护了操作的执行信息&lt;/h4&gt;
&lt;p&gt;用mdn上的话说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Promise is an object representing the eventual completion or failure of an asynchronous operation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说Promise维护了异步操作执行情况的相关信息，pending, fullfilled, rejected&lt;/p&gt;
&lt;p&gt;那除此之外呢？&lt;/p&gt;
&lt;h4&gt;Promise提供了一套描述aysn_ops间执行关系的语言&lt;/h4&gt;
&lt;p&gt;Promise提供了一套Chain规则，让我们方便地描述异步操作的执行过程&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nx"&gt;asyn_operations&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;successCallback&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;failureCallback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;successCallback&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;failureCallback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;failureCallback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nx"&gt;注意&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="nx"&gt;其中&lt;/span&gt;
&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)=&amp;gt;{},&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nx"&gt;简记为&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)=&amp;gt;{})&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)=&amp;gt;{})&lt;/span&gt;&lt;span class="nx"&gt;简记为&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)=&amp;gt;{})&lt;/span&gt;
&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;res&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;Promise&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;resolve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// returns a already resolved promise&lt;/span&gt;
    &lt;span class="c1"&gt;// likewise, Promise.reject(reason) returns a already rejected promise&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="nx"&gt;简记为&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="nx"&gt;所以&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;Promise&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;resolve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="ow"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Promise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;resolve&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;resolve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;在ECMAScript 2017中，提供了更简洁的写法：（本质上是对上述写法的语法糖）&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;async_operations&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;sync_or_async_ops&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;reuslt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
        &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="nx"&gt;sync_or_async_ops&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;failureCallback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;除了.then规则，还有.all和.any, .race...本质上都是对&lt;strong&gt;各个操作间同步关系的描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nf"&gt;Promise.all&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="no"&gt;fn1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;fn2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;fn3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;fn4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="na"&gt;.then&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="no"&gt;res1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;res2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;res3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;res4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="err"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;do&lt;/span&gt; &lt;span class="no"&gt;something&lt;/span&gt;
&lt;span class="err"&gt;})&lt;/span&gt;

&lt;span class="nf"&gt;Promise.all&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;那我们如何创建Promise呢&lt;/h4&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;wait&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;ms&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="ow"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Promise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;resolve&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;setTimeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;resolve&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ms&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;上述定义了一个wait的函数，该函数接受一个ms参数，返回一个Promise对象，其中Promise维护了操作"resolve =&amp;gt; setTimeout(resolve, ms)"的执行情况，&lt;/p&gt;
&lt;p&gt;当我们使用wait时，即&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;then&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class="ow"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Promise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;setTimeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ms&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;从而创建了一个setTimeout的wrapper.&lt;/p&gt;
&lt;p&gt;总的来说，Promise的主要贡献在于优化了异步回调中臃肿不堪的语法&lt;/p&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;p&gt;注意，Promise如果不进行异常捕获，如果执行过程出错，是不会造成程序终止的。&lt;/p&gt;&lt;/div&gt;</description><category>js</category><guid>https://dagrons.github.io/posts/jszhong-de-promiseji-zhi/</guid><pubDate>Tue, 23 Mar 2021 03:18:42 GMT</pubDate></item></channel></rss>