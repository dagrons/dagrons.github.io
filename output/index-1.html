<!DOCTYPE html>
<html lang="zh_cn">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NuLL (旧文章页 1)</title>
<style>
        @font-face {
            font-family: "libretto-icons";
            src:url(assets/fonts/libretto-icons.eot);
            src:url(assets/fonts/libretto-icons.eot#iefix) format("embedded-opentype"),
            url(assets/fonts/libretto-icons.woff) format("woff"),
            url(assets/fonts/libretto-icons.ttf) format("truetype"),
            url(assets/fonts/libretto-icons.svg#libretto-icons) format("svg");
            font-weight: normal;
            font-style: normal;
        }
    </style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono%7CLibre+Baskerville%7CMontserrat%7CPlayfair+Display">
<link rel="stylesheet" href="assets/css/libretto_styles.css">
</head>
<body>
    <!-- Navigation bar -->
    <header class="nav-bar"><div class="site-branding">
            <h1 class="site-title">
                <a href="https://dagrons.github.io/" title="NuLL" rel="home">NuLL</a>
            </h1>
        </div>
        <nav class="site-navigation" role="navigation"><div class="menu-toggle">
                <span class="mobile-site-title">NuLL</span>
            </div>
            <ul class="menu">
<li><a href="archive.html">文章归档</a></li>
                    <li><a href="categories/">标签</a></li>
                    <li><a href="rss.xml">RSS 源</a></li>
            </ul></nav></header><div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/jszhong-de-promiseji-zhi/" rel="bookmark">%B %-23, %2021</a>
                        </span>
                    </div>
                    <h1><a href="posts/jszhong-de-promiseji-zhi/">js学习-理解promise机制</a></h1>
                </div>
                <div class="entry-content">
                        <div>
<h2 id="js-promise">Js中的核心机制-Promise</h2>
<p>“在异步中实现同步”</p>
<p>如果说js中有什么东西造就了他的与众不同，我想，既不是functional programming这种几十年前的老东西，也不是None和undefined这种奇怪的机制，甚至于this的dynamic scope都不足以支撑js成为一门与众不同而独占前端市场的语言，而是他的异步机制，js是专为异步编程设计的语言，不只是体现在语法上，更重要的是其提供的基建。</p>
<p>在前端开发中，相当大的一部分工作是在进行UI渲染和回调处理，这不仅是web独有的特点，而是针对几乎所有前端开发的共有特性，在前端逻辑中，我们经常关注于一个按钮被点击后会发生什么，当我们从服务器中获取数据后要干什么...，于是有了“事件流”的概念，我们将事件流想象成一个队列，主线程从事件流中不断取出事件，并进行处理。</p>
<p>这里涉及两个问题，1. 主线程如何根据事件确定相应的处理逻辑？2. 主线程如何确保处理逻辑不会阻塞</p>
<p>对于问题1，js中提供了相当多的机制，典型的例子就是DOM的事件监听机制，用户在各种事件上注册各种处理函数，从而确定事件对应的处理逻辑，还例如fetch的回调，用于执行fetch返回后的处理逻辑</p>
<p>对于问题2，主线程如何确保处理逻辑不会阻塞，首先，我们要时刻谨记“js是单线程的”，也就是说，所有的操作都在一个线程内完成，这似乎很难理解，但回到我们之前的事件流模型，就不难发现，整个程序所做的事件不过是：</p>
<pre class="code literal-block"><span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">event</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">pop_front</span><span class="p">();</span>
    <span class="nx">handle</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>虽然js是单线程的，但浏览器并非单线程，浏览器只是为每个window开一个js线程，一个UI渲染引擎。</p>
<p>既然js是单线程的语言，所以要求我们的事件处理函数一定是不能阻塞我们的主线程，其中UI渲染事件会被交给UI渲染引擎进行处理，而fetch和setTimeout,setInterval，以及DOM的各种OnXXX事件，如何保证它们被处理的时候不阻塞呢，答案是：异步/non-blocking</p>
<p>在js中，异步/non-blocking常与Promise挂钩</p>
<h3 id="promise">Promise</h3>
<p>在js中，异步/non-blocking的含义就是将一个同步的过程分解成几个步骤，使得原来阻塞的处理逻辑变得不阻塞，举个例子：我们想要从server端获取数据，然后进行处理，但从server端获取数据的过程是会产生阻塞的，于是js提出了promise机制，首先它让fetch变成non-blocking的调用，然后允许我们对fetch的返回数据注册处理函数，但是这个处理函数是在fetch的返回数据确定后执行</p>
<p>所以，什么是Promise机制呢：</p>
<h4 id="promise_1">Promise维护了操作的执行信息</h4>
<p>用mdn上的话说：</p>
<blockquote>
<p>A Promise is an object representing the eventual completion or failure of an asynchronous operation.</p>
</blockquote>
<p>也就是说Promise维护了异步操作执行情况的相关信息，pending, fullfilled, rejected</p>
<p>那除此之外呢？</p>
<h4 id="promiseaysn_ops">Promise提供了一套描述aysn_ops间执行关系的语言</h4>
<p>Promise提供了一套Chain规则，让我们方便地描述异步操作的执行过程</p>
<p>如下：</p>
<pre class="code literal-block"><span class="nx">asyn_operations</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">successCallback</span><span class="p">,</span> <span class="nx">failureCallback</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">successCallback</span><span class="p">,</span> <span class="nx">failureCallback</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
<span class="p">...</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">failureCallback</span><span class="p">)</span>

<span class="nx">注意</span><span class="err">：</span><span class="nx">其中</span>
<span class="mf">1.</span> <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)=&gt;{},</span> <span class="kc">null</span><span class="p">)</span><span class="nx">简记为</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)=&gt;{})</span>
<span class="mf">2.</span> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)=&gt;{})</span><span class="nx">简记为</span><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)=&gt;{})</span>
<span class="mf">3.</span> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">val</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span> <span class="c1">// returns a already resolved promise</span>
    <span class="c1">// likewise, Promise.reject(reason) returns a already rejected promise</span>
<span class="p">})</span>
<span class="nx">简记为</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">val</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
<span class="p">})</span>
<span class="nx">所以</span><span class="err">：</span><span class="k">return</span> <span class="nx">val</span> <span class="o">&lt;=&gt;</span> <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="k">return</span> <span class="ow">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span>
</pre>
<p>在ECMAScript 2017中，提供了更简洁的写法：（本质上是对上述写法的语法糖）</p>
<pre class="code literal-block"><span class="k">async</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">async_operations</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">sync_or_async_ops</span><span class="p">(</span><span class="nx">reuslt</span><span class="p">);</span> 
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">sync_or_async_ops</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">failureCallback</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>除了.then规则，还有.all和.any, .race...本质上都是对<strong>各个操作间同步关系的描述</strong></p>
<p>例如：</p>
<pre class="code literal-block"><span class="nf">Promise.all</span><span class="p">([</span><span class="no">fn1</span><span class="p">,</span> <span class="no">fn2</span><span class="p">,</span> <span class="no">fn3</span><span class="p">,</span> <span class="no">fn4</span><span class="p">])</span>
<span class="na">.then</span><span class="p">(([</span><span class="no">res1</span><span class="p">,</span> <span class="no">res2</span><span class="p">,</span> <span class="no">res3</span><span class="p">,</span> <span class="no">res4</span><span class="p">])</span> <span class="err">=&gt;</span> <span class="err">{</span>
    <span class="nf">do</span> <span class="no">something</span>
<span class="err">})</span>

<span class="nf">Promise.all</span><span class="p">()</span>
</pre>
<h4 id="promise_2">那我们如何创建Promise呢</h4>
<p>例如：</p>
<pre class="code literal-block"><span class="kd">const</span> <span class="nx">wait</span> <span class="o">=</span> <span class="nx">ms</span> <span class="p">=&gt;</span> <span class="ow">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
</pre>
<p>上述定义了一个wait的函数，该函数接受一个ms参数，返回一个Promise对象，其中Promise维护了操作"resolve =&gt; setTimeout(resolve, ms)"的执行情况，</p>
<p>当我们使用wait时，即</p>
<pre class="code literal-block"><span class="nx">wait</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doSomething</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="ow">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">doSomething</span><span class="p">,</span> <span class="nx">ms</span><span class="p">))</span>
</pre>
<p>从而创建了一个setTimeout的wrapper.</p>
<p>总的来说，Promise的主要贡献在于优化了异步回调中臃肿不堪的语法</p>
<h3 id="_1">注意事项</h3>
<p>注意，Promise如果不进行异常捕获，如果执行过程出错，是不会造成程序终止的。</p>
</div>
                </div>
            </article>
</div>
    <!-- Lower Navigation links -->
    <nav class="site-content navigation-post" role="navigation"><div class="previous">
                <a href="." rel="prev" onclick="return false;">
                    <span class="meta-nav">No More Older Entries</span>                </a>
            </div>
            <div class="next">
                <a href="." rel="next">
                    <span class="meta-nav">Newer Entries</span>                </a>
            </div>
    </nav><!-- Page Footer --><section class="footer-sidebar clear" role="complementary"><div class="widget-block">
            <aside class="widget"><h2 class="widget-title">NuLL</h2>
                <div class="widget-text">NuLL</div>
            </aside>
</div>
    </section><!-- Site Attributions --><footer class="site-footer" role="contentinfo"><div class="site-info">
            <p>Contents © 2021         <a href="mailto:heyuehuii@126.com">dagrons</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            <p>Powered by <a href="https://getnikola.com/">Nikola</a> using the <a href="https://note2self.abraham-v.com/libretto-theme-for-nikola/">Libretto theme</a>.</p>
        </div>
        <div class="social">
            <ul class="menu"></ul>
</div>
    </footer>
</body>
</html>
