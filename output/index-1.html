<!DOCTYPE html>
<html><body>
<p>{ set_locale(lang) }}


</p>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="NuLL">
<meta name="author" content="dagrons">
<title>NuLL (旧文章页 1) | NuLL</title>
<link href="assets/css/all.css" rel="stylesheet" type="text/css">
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]--><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<div id="wrp">
        <div id="cont">
            <div id="page">
                <header><h1>
                        <a href="https://dagrons.github.io/" title="NuLL" rel="home">NuLL</a>
                    </h1>
                </header><div id="body">
                    <nav><ul>
<li><a href="https://dagrons.github.io/" title="Home" rel="home"><i class="fa fa-fw fa-home"></i></a></li>
                            <li><a href="https://dagrons.github.io/categories/" title="Tags"><i class="fa fa-fw fa-tags"></i></a></li>
                            <li><a href="https://dagrons.github.io/rss.xml" title="RSS feed"><i class="fa fa-fw fa-rss"></i></a></li>                            
                            <li><a href="https://github.com/dagrons" title="My GitHub repo"><i class="fa fa-fw fa-github"></i></a></li>
                        </ul></nav><div id="content">
        <article class="teaser h-entry post-text"><h1 class="p-name">
<a href="posts/jszhong-de-promiseji-zhi/" class="u-url">js学习-理解promise机制</a>
             <time class="published dt-published" datetime="2021-03-23T11:18:42+08:00">2021-03-23 11:18</time>
</h1>
        <div class="e-content">
        <div>
<h2 id="js-promise">Js中的核心机制-Promise</h2>
<p>“在异步中实现同步”</p>
<p>如果说js中有什么东西造就了他的与众不同，我想，既不是functional programming这种几十年前的老东西，也不是None和undefined这种奇怪的机制，甚至于this的dynamic scope都不足以支撑js成为一门与众不同而独占前端市场的语言，而是他的异步机制，js是专为异步编程设计的语言，不只是体现在语法上，更重要的是其提供的基建。</p>
<p>在前端开发中，相当大的一部分工作是在进行UI渲染和回调处理，这不仅是web独有的特点，而是针对几乎所有前端开发的共有特性，在前端逻辑中，我们经常关注于一个按钮被点击后会发生什么，当我们从服务器中获取数据后要干什么...，于是有了“事件流”的概念，我们将事件流想象成一个队列，主线程从事件流中不断取出事件，并进行处理。</p>
<p>这里涉及两个问题，1. 主线程如何根据事件确定相应的处理逻辑？2. 主线程如何确保处理逻辑不会阻塞</p>
<p>对于问题1，js中提供了相当多的机制，典型的例子就是DOM的事件监听机制，用户在各种事件上注册各种处理函数，从而确定事件对应的处理逻辑，还例如fetch的回调，用于执行fetch返回后的处理逻辑</p>
<p>对于问题2，主线程如何确保处理逻辑不会阻塞，首先，我们要时刻谨记“js是单线程的”，也就是说，所有的操作都在一个线程内完成，这似乎很难理解，但回到我们之前的事件流模型，就不难发现，整个程序所做的事件不过是：</p>
<pre class="code literal-block"><span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">event</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">pop_front</span><span class="p">();</span>
    <span class="nx">handle</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>虽然js是单线程的，但浏览器并非单线程，浏览器只是为每个window开一个js线程，一个UI渲染引擎。</p>
<p>既然js是单线程的语言，所以要求我们的事件处理函数一定是不能阻塞我们的主线程，其中UI渲染事件会被交给UI渲染引擎进行处理，而fetch和setTimeout,setInterval，以及DOM的各种OnXXX事件，如何保证它们被处理的时候不阻塞呢，答案是：异步/non-blocking</p>
<p>在js中，异步/non-blocking常与Promise挂钩</p>
<h3 id="promise">Promise</h3>
<p>在js中，异步/non-blocking的含义就是将一个同步的过程分解成几个步骤，使得原来阻塞的处理逻辑变得不阻塞，举个例子：我们想要从server端获取数据，然后进行处理，但从server端获取数据的过程是会产生阻塞的，于是js提出了promise机制，首先它让fetch变成non-blocking的调用，然后允许我们对fetch的返回数据注册处理函数，但是这个处理函数是在fetch的返回数据确定后执行</p>
<p>所以，什么是Promise机制呢：</p>
<h4 id="promise_1">Promise维护了操作的执行信息</h4>
<p>用mdn上的话说：</p>
<blockquote>
<p>A Promise is an object representing the eventual completion or failure of an asynchronous operation.</p>
</blockquote>
<p>也就是说Promise维护了异步操作执行情况的相关信息，pending, fullfilled, rejected</p>
<p>那除此之外呢？</p>
<h4 id="promiseaysn_ops">Promise提供了一套描述aysn_ops间执行关系的语言</h4>
<p>Promise提供了一套Chain规则，让我们方便地描述异步操作的执行过程</p>
<p>如下：</p>
<pre class="code literal-block"><span class="nx">asyn_operations</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">successCallback</span><span class="p">,</span> <span class="nx">failureCallback</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">successCallback</span><span class="p">,</span> <span class="nx">failureCallback</span><span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(...)</span>
<span class="p">...</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">failureCallback</span><span class="p">)</span>

<span class="nx">注意</span><span class="err">：</span><span class="nx">其中</span>
<span class="mf">1.</span> <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)=&gt;{},</span> <span class="kc">null</span><span class="p">)</span><span class="nx">简记为</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)=&gt;{})</span>
<span class="mf">2.</span> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)=&gt;{})</span><span class="nx">简记为</span><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)=&gt;{})</span>
<span class="mf">3.</span> <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">val</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span> <span class="c1">// returns a already resolved promise</span>
    <span class="c1">// likewise, Promise.reject(reason) returns a already rejected promise</span>
<span class="p">})</span>
<span class="nx">简记为</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">val</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
<span class="p">})</span>
<span class="nx">所以</span><span class="err">：</span><span class="k">return</span> <span class="nx">val</span> <span class="o">&lt;=&gt;</span> <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="k">return</span> <span class="ow">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span>
</pre>
<p>在ECMAScript 2017中，提供了更简洁的写法：（本质上是对上述写法的语法糖）</p>
<pre class="code literal-block"><span class="k">async</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">async_operations</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">sync_or_async_ops</span><span class="p">(</span><span class="nx">reuslt</span><span class="p">);</span> 
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">sync_or_async_ops</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">failureCallback</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>除了.then规则，还有.all和.any, .race...本质上都是对<strong>各个操作间同步关系的描述</strong></p>
<p>例如：</p>
<pre class="code literal-block"><span class="nf">Promise.all</span><span class="p">([</span><span class="no">fn1</span><span class="p">,</span> <span class="no">fn2</span><span class="p">,</span> <span class="no">fn3</span><span class="p">,</span> <span class="no">fn4</span><span class="p">])</span>
<span class="na">.then</span><span class="p">(([</span><span class="no">res1</span><span class="p">,</span> <span class="no">res2</span><span class="p">,</span> <span class="no">res3</span><span class="p">,</span> <span class="no">res4</span><span class="p">])</span> <span class="err">=&gt;</span> <span class="err">{</span>
    <span class="nf">do</span> <span class="no">something</span>
<span class="err">})</span>

<span class="nf">Promise.all</span><span class="p">()</span>
</pre>
<h4 id="promise_2">那我们如何创建Promise呢</h4>
<p>例如：</p>
<pre class="code literal-block"><span class="kd">const</span> <span class="nx">wait</span> <span class="o">=</span> <span class="nx">ms</span> <span class="p">=&gt;</span> <span class="ow">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>
</pre>
<p>上述定义了一个wait的函数，该函数接受一个ms参数，返回一个Promise对象，其中Promise维护了操作"resolve =&gt; setTimeout(resolve, ms)"的执行情况，</p>
<p>当我们使用wait时，即</p>
<pre class="code literal-block"><span class="nx">wait</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">doSomething</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="ow">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">doSomething</span><span class="p">,</span> <span class="nx">ms</span><span class="p">))</span>
</pre>
<p>从而创建了一个setTimeout的wrapper.</p>
<p>总的来说，Promise的主要贡献在于优化了异步回调中臃肿不堪的语法</p>
<h3 id="_1">注意事项</h3>
<p>注意，Promise如果不进行异常捕获，如果执行过程出错，是不会造成程序终止的。</p>
</div>
        </div>
            
        </article><div>
        <ul class="pager">
<li class="previous">
                <a href="." rel="prev">← 较新的文章</a>
            </li>
        </ul>
</div>

    
	
                    </div>
                </div>
                <div id="ftr">
                </div>
            </div>
        </div>
    </div>
	<footer><small>Contents © 2021         <a href="mailto:heyuehuii@126.com">dagrons</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </small>
	</footer>
</body></html>
