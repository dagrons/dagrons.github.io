<h1>Go学习第一天, GoTooling</h1>
<h2>GOPATH vs GOROOT</h2>
<blockquote>
<p>The GOPATH environment variable lists places to look for Go code. On Unix, the value is a colon-separated string, On Windows, the value is a semicolon-separated string, On Plan9, the value is a list
GOPATH must be set to get, build and install packages outside the standard Go Tree(即GO SDK)</p>
<p>GOROOT is where the go SDK being installed</p>
</blockquote>
<p>GOPATH就是Go安装第三方库的位置, 通过改变这个，我们可以自由切换依赖环境, 实现类似于python中virtualenv的功能</p>
<p>GOROOT就是Go SDK的安装位置</p>
<h2>创建第一个GO可执行程序</h2>
<p>在go1.2以前, 如果要创建一个命名类似于"github.com/foo"的包的话, 需要在"$GOPATH/src/github.com"下创建, 流程如下:</p>
<pre class="code literal-block">mkdir -p <span class="nv">$GOPATH</span>/src/github.com/foo
</pre>
<p>在编译go项目后, 可以通过go install进行安装, 会将项目安装在"$GOPATH/bin/"下:</p>
<pre class="code literal-block"><span class="k">go</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">foo</span><span class="o">/</span><span class="n">hello</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nc">binary</span><span class="w"></span>
<span class="err">$</span><span class="n">GOPATH</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">hello</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">it</span><span class="w"></span>
</pre>
<p>如果将GOPATH加入到了PATH中, 可以直接运行</p>
<pre class="code literal-block">hello
</pre>
<h2>创建第一个GO module</h2>
<p>大致流程和创建GO程序差不多, 但和GO程序的区别在于GO包编译并不会生成可执行文件, 因此我们并不需要使用"go install"命令进行安装, 
在完成后, 使用"go build"测试一下包能够通过编译即可</p>
<pre class="code literal-block">mkdir <span class="nv">$GOPATH</span>/src/github.com/foo/stringutil
go build github.com/goo/stringutil
</pre>
<h2>更先进的项目环境管理方式</h2>
<p>在go1.2后, 通过go.mod, 我们不再需要在$GOPATH/src/下进行项目开发了, 相应的, 我们可以通过定义go.mod来创建module</p>
<p>首先执行go init生成用于管理的go.mod和go.sum文件</p>
<pre class="code literal-block">go mod init github.com/foo 
</pre>
<p>一个典型的go.mod如下, </p>
<pre class="code literal-block"><span class="k">module</span><span class="w"> </span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">dagrons</span><span class="o">/</span><span class="n">godw</span><span class="w"></span>

<span class="k">go</span><span class="w"> </span><span class="mf">1.16</span><span class="w"></span>

<span class="n">require</span><span class="w"> </span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">gin</span><span class="o">-</span><span class="n">gonic</span><span class="o">/</span><span class="n">gin</span><span class="w"> </span><span class="n">v1</span><span class="mf">.7.2</span><span class="w"></span>
</pre>
<p>指定了module名, go SDK版本, 以及依赖的第三方库及版本, </p>
<p>这种项目依赖管理方式和package.json和Gemfile类似, 更加好用</p>
<p>在go.mod编写完成后, 需要通过"go tidy mod"进行依赖解析, 会下载并解析好所有的依赖关系</p>
<pre class="code literal-block">go mod tidy
</pre>